#lang rhombus

import:
  rhombus/meta open
  meta:
    lib("racket/syntax.rkt") as syntax

export:
  datatype
  ematch
  

def adt_information: #false

meta:
  fun
  | ensure_constructor_exists(constr, no_args, '[]'):
      error("Inexhaustive match: Constructor " ++ to_string(constr) ++ " not present")
  | ensure_constructor_exists(constr, no_args, '[[$oconstr ... ($arg, ...)], $rest, ...]'):
      cond 
      | to_string(constr) != to_string('$oconstr ...'):
          ensure_constructor_exists(constr, no_args, '[$rest, ...]')
      | [arg, ...].length() != no_args:
          error("Number of arguments does not match: " ++ to_string('$oconstr ... ($arg, ...)') ++ " should have " ++ to_string(no_args) ++ " arguments")
      | ~else: #void

expr.macro
| 'ematch $expr_term ...
   | $case ...:
       $body
       ...
   | ...':
     def '$(expr :: expr_meta.Parsed)': '$expr_term ...'
     def data: statinfo_meta.lookup('$expr', 'adt_information')
     match data
     | #false: error("Insufficient static information on \"" ++ to_string(expr) ++ "\" in ematch")
     | '[[$scons, $scons_args], ...]':
         for:
           each [cons, cons_args]: [[scons,scons_args], ...]
           def no_args: match cons_args | '[$arg, ...]': [arg, ...].length()
           ensure_constructor_exists(
               cons, no_args,
               '[[$case ...], ...]'
           )
           
         'match $expr
          | $case ...:
             $body
             ...
          | ...'

defn.macro
| 'datatype $name
   | $constructor ($arg ..., ...)
   | ...':
   def name_stx: Syntax.make('$name')
   def super_name:
     Syntax.make(
       syntax.#{format-id}(
         name_stx,
         "~a_super",
         name
       )
     ).relocate(name)
   '«class $super_name ():
       nonfinal

       static_info:
         '((adt_information, [[$constructor, [$arg ..., ...]], ...]))'

     annot.macro '$name': '$super_name'

     class $constructor ($arg ..., ...):
       extends $super_name
     ...
    »'
